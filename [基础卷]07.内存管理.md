## 内存基础知识

### 内存区域的划分
1. 栈：局部变量
2. 堆：手动创建和管理的内存空间，使用 `new` 和 `malloc` 请求创建，`delete` 和 `free` 来回收，如果管理不当，会造成内存泄漏
3. 常量存储区：程序启动时自动创建的只读内存空间，用来存储 `const` 常量以及代码中的字符串
4. 静态存储区：程序启动时自动创建的内存空间，在 `main` 函数之前创建，用来存储静态变量和全局变量，可读可写，但不能动态创建
5. 代码存储区：存储代码二进制内容的只读空间


### new 和 malloc 的区别
1. `new` 分配的内存使用 `delete` 来释放，`malloc` 分配的内存使用 `free` 来释放
2. `new/delete` 是操作符，`malloc/free` 是标准库函数
3. `malloc/free` 只分配、释放内存，`new/delete` 还可以用于创建、释放对象，会自动执行对象的构造和析构函数
4. `new/delete` 的写法比 `malloc/free` 简洁 *(这个不值一提吧)*
5. `new/delete` 在创建数组时需要特别注意，比如：`int* p = new int[100];`，在释放时，也要加上`[]`，比如：`delete []p;`


### 堆和栈的区别
1. 栈空间是系统自动分配和回收的，堆空间是程序员动态分配和回收的
2. 栈空间是有限的，当超出时，就会出现溢出，Linux下默认的栈空间为**10MB**，Windows默认为**1MB**；而堆空间一般足够大，在32位系统下，理论上有**4GB**可用
3. 栈空间的内存地址是连续的，效率高；堆空间的内存地址是不连续的，效率较低，切容易产生内存碎片
**总结：**
1. 要控制对象的生命周期，必须用堆；
2. 需要分配大块内存，必须用堆；
3. 需要分配的内存大小是动态的，倾向于用堆；
4. 其他情况尽量用栈，以保证安全高效，无内存碎片，减少内存泄漏。

---

## 内存泄漏、野指针和跨动态链接库的内存使用
1. 内存泄漏
    - 问题：隐性，最终耗光内存，导致程序崩溃
    - 原因：分配的内存没有及时、正确的释放
    - 检测：valgrind、mtrace、debug_new，引用计数，重载全局的new和delete
2. 野指针
    - 问题：使用了指向无意义内存的指针
    - 预防：使用前检查，使用后置为NULL
3. 动态链接库的内存
    - 问题：在Windows中释放从DLL中创建的内存会导致程序崩溃，而在Linux上则可以正常运行，这是因为两者的堆实现不同导致的
    - Windows允许一个进程内可以存在多个堆，在一个堆中分配的内存在其他堆中释放，这是跨DLL释放内存崩溃的根本原因；而Linux的进程只有一个堆，所有堆内存的分配和释放都在这个堆上进行，所以运行正常。

---

### Cocos2d-x 的引用计数
1. `retain`, `release`, `autorelease`
2. `Ref` 类封装了引用计数，还自带了内存泄漏检测功能，开启`CC_USE_MEM_LEAK_DETECTION` 宏即可
3. 引用计数：
    - 构造时，引用计数成员变量置为1；
    - 调用`retain`时，引用计数自增1；
    - 调用`release`时，引用计数自减1，并判断引用计数是否为0，若为0则执行回收操作；
    - 调用`autorelease`时，引用计数自增1，并在切换至下一帧时自减1；
    - 若`new`了`一个`Ref`对象，如果忘记调用`release`，是存在内存泄漏的;`autorelease`可以有效防止这个问题，调用`autorelease`之后，`autorelease`将对象的释放交给自动释放池进行管理，因此之后可以省略手动调用`release`来释放对象；
    - `autorelease`的优点：
        - 一次设定之后，无需再担心内存泄漏问题；
        - 容易维护；

---

### 容器对象的内存管理
1. 三种常用的Cocos2dx容器：`Vector`,`Set`,`Map`
2. `Vector` 相当于一个使用数组实现的容器，对每一个添加进来的对象都会执行一次`retain`操作，当对象从数组中删除时，会调用对象的`release`方法来释放，在数组被删除、析构或重新初始化的时候，会清空所有对象，并调用它们的`release`方法。
3. `Map`是一种`key-value`的关联容器，每个被添加到容器中的对象都会被`retain`，被删除的对象都会被`release`。
4. `Set`是`CCObject`的几个，主要增加了对容器内元素的`retain`和`release`调用。**优点是查找效率高，插入删除也相对较高，并且可以快速得到两个set之间的交集、并集和差集；但插入和删除的效率低于list，遍历的效率低于vector。

---

### 复制对象
1. `CCObject/Clonabel`提供`copy`函数来拷贝对象；
2. `copy`返回重新`new`出来的一个对象，并且这个对象中的值与源对象一致。

---

### 内存优化
1. 频繁的使用`new/delete/malloc/free` 等方法来创建和释放内存，会带来一定的性能消耗；大量分配不大小不规则的内存块，会使内存中存在大量内存碎片*（影响内存分配的效率，如win32是按照“页来管理内存的，每一页有64KB内存，当先创建40KB内存，再创建25KB内存时，name第一页已经放不下25KB，就会放在第二页上，中间空出这24KB，就是内存碎片了”）。
2. 内存池可以有效的环节上面的问题带来的性能消耗，内存池是一个内存管理方式，实现内存池，需要实现内存申请、回收等功能。内存池的基本功能如下：
    - 管理内存块，当需要分配时，先从池中查找可用的内存，找不到再进行new或malloc操作；
    - 当需要释放时，将内存会收到内存池中；
    - 分配内存时，可以考虑一次性分配适量的内存，以保证分配连续、对齐的内存，然后进行切分，方便内存重用；
    - 回收内存时，可根据当前空闲内存的总量来决定是否释放一部分空闲内存，以确保空闲内存的水位不会太高；

